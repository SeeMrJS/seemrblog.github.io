### javascript标准引用
先放一个ECMAScript的中文规范链接 https://yanhaijing.com/es5/ 
#### js中的表达式运算
js中，一切都是表达式的运算，可以将js代码理解成表达式的连续求值
```js
a = 1;
obj.x;
1;
```
这些都是表达式运算（1是单值表达式）
#### 表达式的计算结果是什么
表达式的计算结果即 **标准引用**
#### 标准引用长什么样子
既然是个规范概念，那么 **标准引用** 有没有其特定结构呢。
当然是有的：
```js
obj.x 标准引用结构大致如下 
{
  base: obj,
  value: x,
  strict: false /*这个属性代表是否是严格模式*/
}
```
#### 标准引用存在的意义
这里我也无法严格描述，我用自己的理解大致说一下：
以 obj.x 为例
如果没有标准引用，那么这个表达式最终的求值结果可能就是x的值，obj.x可能是一个基本类型，比如5，也有可能是个函数，比如() => 'hello world'。
我们知道，5是个基本类型，函数是个引用类型（我们假设访问地址为0x123）。
那么不管是个什么类型，我们最终会得到5或者一个引用地址。这个值只包含了x的信息，而丢失了obj相关的信息。
#### 丢失信息会带来什么影响
我们知道，js中的方法调用是类似 obj.x() ,如果我们最终求值只得到了x的信息，那么this的信息要怎么获取。要知道，普通函数的this值是在调用的时候确定的。
#### 标准引用与this
从上来面的文字来看，this应该和标准引用的base属性脱不了干系（后面将标准引用简写为Ref）。
可以简单理解为，this指向只和Ref.base以及call有关（函数都是call调用的）。
>> 隐式绑定：
>> 即默认call（null），如obj.x()。此时this即为base值  

>> 默认绑定：
>> 即直接调用函数x(),此时base会根据strict的值来定，也就是我们知道的，严格模式下base为undefined，非严格模式下为window  

>> call绑定：
>> call传递的参数会当作base的值
#### 求值
回到标准引用，那么为什么我们写这样的代码：
```js
obj = { 
  x:5
}
obj.x
//输出5
```
为什么最终的输出是5，而不是一个标准引用？表达式的返回值不应该是标准引用吗？js中只有引擎对标准引用感兴趣，用户并不在乎什么是标准引用，并且实际上能够展现在屏幕上的，也只有数字，字符串和布尔值这种基本类型。js中的语句也是有返回值的，语句的返回值类型称为完成类型，并且js中的代码执行，本质上是语句执行。完成类型使用语言底层的getValue方法将Ref.value给取出来。所以会返回5。这个操作，我们可以称为**对标准引用求值**。当然，**求值也必定造成信息的丢失**。
#### 赋值表达式的手性
```js
x = 5
```
根据之前的观点，x 和 5 都是表达式，都会被运算成标准引用。这个赋值语句的含义是，将5赋值给x的计算结果（标准引用）
```js
x = x
```
那上面这个代码要如何理解呢。即理解为 将右侧的x的计算结果的求值结果(getValue(Ref.value)) 赋值给左侧x的计算结果。并且，由于这是个语句执行，最终这个赋值语句是有返回值的，返回值是右侧的值。
#### this是如何丢失绑定的
```
x = arg => console.log(this)
(indow.x = window.x)()
```




 
