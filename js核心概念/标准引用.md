### javascript标准引用
先放一个ECMAScript的中文规范链接 https://yanhaijing.com/es5/ 
#### js中的表达式运算
js中，一切都是表达式的运算，可以将js代码理解成表达式的连续求值
```js
a = 1;
obj.x;
1;
```
这些都是表达式运算（1是单值表达式）
#### 表达式的计算结果是什么
表达式的计算结果即 **标准引用**
#### 标准引用长什么样子
既然是个规范概念，那么 **标准引用** 有没有其特定结构呢。
当然是有的：
```js
obj.x 标准引用结构大致如下 
{
  base: obj,
  value: x,
  strict: false /*这个属性代表是否是严格模式*/
}
```
#### 标准引用存在的意义
这里我也无法严格描述，我用自己的理解大致说一下：
以 obj.x 为例
如果没有标准引用，那么这个表达式最终的求值结果可能就是x的值，obj.x可能是一个基本类型，比如5，也有可能是个函数，比如() => 'hello world'。
我们知道，5是个基本类型，函数是个引用类型（我们假设访问地址为0x123）。
那么不管是个什么类型，我们最终会得到5或者一个引用地址。这个值只包含了x的信息，而丢失了obj相关的信息。
##### 丢失信息会带来什么影响
我们知道，js中的方法调用是类似 obj.x() ,如果我们最终求值只得到了x的信息，那么this的信息要怎么获取。要知道，普通函数的this值是在调用的时候确定的。
#### 标准引用与this
从上来面的文字来看，this应该和标准引用的base属性脱不了干系（后面将标准引用简写为Ref）。
可以简单理解为，this指向只和Ref.base以及call有关（函数都是call调用的）。
>> 隐式绑定：
>> 即默认call（null），如obj.x()。此时this即为base值
>> 默认绑定：
>> 即直接调用函数x(),此时base会根据strict的值来定，也就是我们知道的，严格模式下base为undefined，非严格模式下为window
>> call绑定：
>> call传递的参数会当作base的值
#### 求值
回到标准引用，那么为什么我们写这样的代码：
```js
obj = { 
  x:5
}
obj.x
//输出5
```
为什么最终的输出是5

 
